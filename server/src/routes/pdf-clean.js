import express from 'express';
import puppeteer from 'puppeteer';
import AWS from 'aws-sdk';
import path from 'path';
import fs from 'fs';

// Configure Puppeteer for Render deployment
if (process.env.NODE_ENV === 'production') {
  process.env.PUPPETEER_CACHE_DIR = '/opt/render/.cache/puppeteer';
  process.env.PUPPETEER_SKIP_CHROMIUM_DOWNLOAD = 'false';
  // Set the executable path directly
  process.env.PUPPETEER_EXECUTABLE_PATH = '/opt/render/.cache/puppeteer/chrome/linux-138.0.7204.157/chrome-linux64/chrome';
}

const router = express.Router();

// Handle preflight requests for PDF endpoints
router.options('*', (req, res) => {
  res.header('Access-Control-Allow-Origin', 'https://app.mintellect.xyz');
  res.header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
  res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization');
  res.status(200).end();
});

// Configure AWS S3
const s3 = new AWS.S3({
  accessKeyId: process.env.AWS_ACCESS_KEY_ID,
  secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
  region: process.env.AWS_REGION || 'us-east-1'
});

const BUCKET_NAME = process.env.AWS_S3_BUCKET || 'mintellect-pdfs';

// Helper function to get logo as base64
const getLogoBase64 = () => {
  try {
    const logoPath = path.join(process.cwd(), 'src', 'public', 'img', 'Mintellect_logo.png');
    console.log('Looking for logo at:', logoPath);
    if (fs.existsSync(logoPath)) {
      console.log('Logo file found!');
      const logoBuffer = fs.readFileSync(logoPath);
      const base64Logo = `data:image/png;base64,${logoBuffer.toString('base64')}`;
      console.log('Logo converted to base64, length:', base64Logo.length);
      return base64Logo;
    } else {
      console.log('Logo file not found at:', logoPath);
    }
  } catch (error) {
    console.error('Error reading logo file:', error);
  }
  // Fallback to a simple text logo if file not found
  console.log('Using fallback text logo');
  return null;
};

// Test endpoint for simple PDF generation
router.get('/test-pdf', async (req, res) => {
  try {
    console.log('Testing PDF generation...');
    
    const htmlContent = `
      <!DOCTYPE html>
      <html>
      <head>
        <title>Test PDF</title>
        <style>
          body { font-family: Arial, sans-serif; padding: 20px; }
          h1 { color: #2c5aa0; }
        </style>
      </head>
      <body>
        <h1>Test PDF Generation</h1>
        <p>This is a test PDF generated by Mintellect.</p>
        <p>Timestamp: ${new Date().toISOString()}</p>
      </body>
      </html>
    `;
    
    const pdf = await generatePDF(htmlContent);
    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader('Content-Disposition', 'inline; filename="test.pdf"');
    res.end(pdf);
    
  } catch (error) {
    console.error('Test PDF generation failed:', error);
    res.status(500).json({ error: error.message });
  }
});

// Direct PDF generation (sends PDF directly to client)
router.post('/generate-plagiarism-report-direct', async (req, res) => {
  try {
    console.log('Generating PDF and sending directly to client...');
    
    const { plagiarismData, documentName, sources } = req.body;
    
    if (!plagiarismData || !documentName) {
      return res.status(400).json({
        success: false,
        error: 'Missing required fields: plagiarismData and documentName'
      });
    }
    
    const htmlContent = generatePlagiarismReportHTML(plagiarismData, documentName, sources);
    console.log('HTML content generated, length:', htmlContent.length);
    
    const pdf = await generatePDF(htmlContent);
    
    if (!pdf || pdf.length === 0) {
      throw new Error('PDF generation failed - empty result');
    }
    
    // Check if PDF starts with the correct magic number
    const pdfHeader = pdf.slice(0, 4).toString('ascii');
    if (pdfHeader !== '%PDF') {
      console.error('Invalid PDF header:', pdfHeader);
      throw new Error('PDF generation failed - invalid PDF format');
    }
    
    console.log('PDF generated successfully, size:', pdf.length, 'bytes');
    console.log('PDF header:', pdfHeader);
    
    // Generate filename
    const timestamp = Date.now();
    const sanitizedName = documentName.replace(/[^a-z0-9]/gi, '_').toLowerCase();
    const filename = `${sanitizedName}_plagiarism_report_${timestamp}.pdf`;
    
    console.log('PDF generated, sending directly to client:', filename);
    
    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader('Content-Disposition', `inline; filename="${filename}"`);
    res.setHeader('Access-Control-Allow-Origin', 'https://app.mintellect.xyz');
    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');
    
    res.end(pdf);
    
  } catch (error) {
    console.error('Direct PDF generation error:', error);
    res.status(500).json({ 
      success: false, 
      error: 'PDF generation failed',
      details: error.message 
    });
  }
});

// Generate PDF and upload to S3
router.post('/generate-plagiarism-report-s3', async (req, res) => {
  try {
    console.log('Generating PDF for S3 storage...');
    
    const { plagiarismData, documentName, sources } = req.body;
    
    if (!plagiarismData || !documentName) {
      return res.status(400).json({
        success: false,
        error: 'Missing required fields: plagiarismData and documentName'
      });
    }
    
    const htmlContent = generatePlagiarismReportHTML(plagiarismData, documentName, sources);
    console.log('HTML content generated, length:', htmlContent.length);
    
    const pdf = await generatePDF(htmlContent);
    
    if (!pdf || pdf.length === 0) {
      throw new Error('PDF generation failed - empty result');
    }
    
    // Check if PDF starts with the correct magic number
    const pdfHeader = pdf.slice(0, 4).toString('ascii');
    if (pdfHeader !== '%PDF') {
      console.error('Invalid PDF header:', pdfHeader);
      throw new Error('PDF generation failed - invalid PDF format');
    }
    
    console.log('PDF generated successfully, size:', pdf.length, 'bytes');
    
    // Generate filename
    const timestamp = Date.now();
    const sanitizedName = documentName.replace(/[^a-z0-9]/gi, '_').toLowerCase();
    const filename = `${sanitizedName}_plagiarism_report_${timestamp}.pdf`;
    
    // Upload to S3
    const uploadParams = {
      Bucket: BUCKET_NAME,
      Key: filename,
      Body: pdf,
      ContentType: 'application/pdf',
      ACL: 'public-read'
    };
    
    console.log('Uploading to S3:', filename);
    const uploadResult = await s3.upload(uploadParams).promise();
    console.log('Upload successful:', uploadResult.Location);
    
    res.json({
      success: true,
      pdfUrl: uploadResult.Location,
      filename: filename,
      size: pdf.length
    });
    
  } catch (error) {
    console.error('S3 PDF generation error:', error);
    res.status(500).json({ 
      success: false, 
      error: 'PDF generation and upload failed',
      details: error.message 
    });
  }
});

// Generate Trust Score Report PDF
router.post('/generate-trust-score-report-s3', async (req, res) => {
  try {
    console.log('Generating Trust Score Report PDF for S3 storage...');
    
    const { trustScoreData, documentName } = req.body;
    
    if (!trustScoreData || !documentName) {
      return res.status(400).json({
        success: false,
        error: 'Missing required fields: trustScoreData and documentName'
      });
    }
    
    const htmlContent = generateTrustScoreReportHTML(trustScoreData, documentName);
    console.log('Trust Score HTML content generated, length:', htmlContent.length);
    
    const pdf = await generatePDF(htmlContent);
    
    if (!pdf || pdf.length === 0) {
      throw new Error('PDF generation failed - empty result');
    }
    
    // Check if PDF starts with the correct magic number
    const pdfHeader = pdf.slice(0, 4).toString('ascii');
    if (pdfHeader !== '%PDF') {
      console.error('Invalid PDF header:', pdfHeader);
      throw new Error('PDF generation failed - invalid PDF format');
    }
    
    console.log('Trust Score PDF generated successfully, size:', pdf.length, 'bytes');
    
    // Generate filename
    const timestamp = Date.now();
    const sanitizedName = documentName.replace(/[^a-z0-9]/gi, '_').toLowerCase();
    const filename = `${sanitizedName}_trust_score_report_${timestamp}.pdf`;
    
    // Upload to S3
    const uploadParams = {
      Bucket: BUCKET_NAME,
      Key: filename,
      Body: pdf,
      ContentType: 'application/pdf',
      ACL: 'public-read'
    };
    
    console.log('Uploading Trust Score PDF to S3:', filename);
    const uploadResult = await s3.upload(uploadParams).promise();
    console.log('Upload successful:', uploadResult.Location);
    
    res.json({
      success: true,
      pdfUrl: uploadResult.Location,
      filename: filename,
      size: pdf.length
    });
    
  } catch (error) {
    console.error('S3 Trust Score Report generation error:', error);
    res.status(500).json({ 
      success: false, 
      error: 'Trust Score PDF generation and upload failed',
      details: error.message 
    });
  }
});

// Enhanced PDF generation function with better Chrome detection
async function generatePDF(htmlContent) {
  try {
    console.log('Starting PDF generation...');
    
    // Try to find Chrome in common locations (prioritize Puppeteer's bundled Chrome)
    const possibleChromePaths = [
      // Puppeteer's bundled Chrome paths (specific version from build log)
      '/opt/render/.cache/puppeteer/chrome/linux-138.0.7204.157/chrome-linux64/chrome',
      // Environment variables
      process.env.CHROME_BIN,
      process.env.PUPPETEER_EXECUTABLE_PATH,
      // System Chrome paths
      '/usr/bin/google-chrome',
      '/usr/bin/chromium-browser',
      '/usr/bin/chromium',
      '/opt/google/chrome/chrome',
      '/usr/bin/google-chrome-stable'
    ].filter(Boolean);
    
    console.log('Possible Chrome paths:', possibleChromePaths);
    
    let executablePath;
    for (const path of possibleChromePaths) {
      try {
        const fs = await import('fs');
        if (fs.existsSync(path)) {
          console.log('Chrome file exists at:', path);
          // Check if it's executable
          try {
            fs.accessSync(path, fs.constants.F_OK | fs.constants.R_OK | fs.constants.X_OK);
            executablePath = path;
            console.log('Found executable Chrome at:', executablePath);
            break;
          } catch (accessError) {
            console.log('Chrome found but not executable, attempting to fix permissions:', path);
            try {
              fs.chmodSync(path, '755');
              executablePath = path;
              console.log('Made Chrome executable and using:', executablePath);
              break;
            } catch (chmodError) {
              console.log('Could not make Chrome executable:', chmodError.message);
            }
          }
        }
      } catch (e) {
        console.log('Could not check path:', path, e.message);
      }
    }
    
    // If no specific path found, try to find Puppeteer's Chrome dynamically
    if (!executablePath) {
      try {
        const fs = await import('fs');
        const puppeteerCacheDir = '/opt/render/.cache/puppeteer/chrome';
        if (fs.existsSync(puppeteerCacheDir)) {
          const chromeDirs = fs.readdirSync(puppeteerCacheDir);
          for (const dir of chromeDirs) {
            // Try different possible Chrome paths
            const possiblePaths = [
              `${puppeteerCacheDir}/${dir}/chrome-linux64/chrome`,
              `${puppeteerCacheDir}/${dir}/chrome-linux/chrome`,
              `${puppeteerCacheDir}/${dir}/chrome`
            ];
            
            for (const chromePath of possiblePaths) {
              if (fs.existsSync(chromePath)) {
                // Check if the file is executable
                try {
                  fs.accessSync(chromePath, fs.constants.F_OK | fs.constants.R_OK | fs.constants.X_OK);
                  executablePath = chromePath;
                  console.log('Found executable Puppeteer Chrome at:', executablePath);
                  break;
                } catch (accessError) {
                  console.log('Chrome found but not executable:', chromePath);
                  // Make it executable
                  try {
                    fs.chmodSync(chromePath, '755');
                    executablePath = chromePath;
                    console.log('Made Chrome executable and using:', executablePath);
                    break;
                  } catch (chmodError) {
                    console.log('Could not make Chrome executable:', chmodError.message);
                  }
                }
              }
            }
            if (executablePath) break;
          }
        }
      } catch (e) {
        console.log('Could not search Puppeteer cache directory:', e.message);
      }
    }
    
    // Configure launch options for Render deployment
    const launchOptions = {
      headless: 'new',
      args: [
        '--no-sandbox', 
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage',
        '--disable-gpu',
        '--no-first-run',
        '--disable-web-security',
        '--disable-features=VizDisplayCompositor',
        '--disable-extensions',
        '--disable-plugins',
        '--disable-images',
        '--disable-javascript',
        '--disable-background-timer-throttling',
        '--disable-backgrounding-occluded-windows',
        '--disable-renderer-backgrounding',
        '--disable-field-trial-config',
        '--disable-ipc-flooding-protection',
        '--single-process',
        '--no-zygote'
      ]
    };
    
    // Set executablePath if we found one, otherwise try the known path
    if (executablePath) {
      launchOptions.executablePath = executablePath;
      console.log('Using Chrome executable:', executablePath);
    } else {
      // Try the known Chrome path from the build log
      const knownChromePath = '/opt/render/.cache/puppeteer/chrome/linux-138.0.7204.157/chrome-linux64/chrome';
      try {
        const fs = await import('fs');
        if (fs.existsSync(knownChromePath)) {
          console.log('Using known Chrome path:', knownChromePath);
          launchOptions.executablePath = knownChromePath;
        } else {
          console.log('Known Chrome path not found, using Puppeteer default');
          // Set the cache directory for Puppeteer
          process.env.PUPPETEER_CACHE_DIR = '/opt/render/.cache/puppeteer';
        }
      } catch (e) {
        console.log('Error checking known Chrome path:', e.message);
        process.env.PUPPETEER_CACHE_DIR = '/opt/render/.cache/puppeteer';
      }
    }
    
    console.log('Launching Puppeteer with options:', JSON.stringify(launchOptions, null, 2));
    const browser = await puppeteer.launch(launchOptions);
    
    const page = await browser.newPage();
    
    try {
      console.log('Setting viewport...');
      await page.setViewport({ width: 1200, height: 800 });
      
      console.log('Setting content...');
      await page.setContent(htmlContent, { waitUntil: 'networkidle0' });
      
      console.log('Generating PDF...');
      const pdf = await page.pdf({
        format: 'A4',
        printBackground: true,
        margin: {
          top: '20px',
          right: '20px',
          bottom: '20px',
          left: '20px'
        }
      });
      
      console.log('PDF generated successfully, size:', pdf.length, 'bytes');
      await browser.close();
      return pdf;
      
    } catch (error) {
      console.error('Puppeteer error:', error);
      await browser.close();
      
      // Alternative PDF generation using a simple HTML to PDF approach
      try {
        const alternativeBrowser = await puppeteer.launch({
          headless: 'new',
          args: [
            '--no-sandbox', 
            '--disable-setuid-sandbox',
            '--disable-dev-shm-usage',
            '--disable-gpu',
            '--no-first-run',
            '--disable-web-security',
            '--disable-features=VizDisplayCompositor',
            '--disable-extensions',
            '--disable-plugins',
            '--disable-images',
            '--disable-javascript',
            '--disable-background-timer-throttling',
            '--disable-backgrounding-occluded-windows',
            '--disable-renderer-backgrounding',
            '--disable-field-trial-config',
            '--disable-ipc-flooding-protection',
            '--single-process',
            '--no-zygote'
          ]
        });
        
        const altPage = await alternativeBrowser.newPage();
        await altPage.setContent(htmlContent, { waitUntil: 'networkidle0' });
        const pdfBuffer = await altPage.pdf({
          format: 'A4',
          printBackground: true,
          margin: {
            top: '20px',
            right: '20px',
            bottom: '20px',
            left: '20px'
          }
        });
        await alternativeBrowser.close();
        
        console.log('Alternative PDF generation successful');
        return pdfBuffer;
        
      } catch (altError) {
        console.error('Alternative PDF generation failed:', altError);
        throw new Error('PDF generation failed: ' + altError.message);
      }
    }
    
  } catch (error) {
    console.error('PDF generation error:', error);
    throw error;
  }
}

// Generate HTML for plagiarism report
function generatePlagiarismReportHTML(plagiarismData, documentName, sources = []) {
  const logoBase64 = getLogoBase64();
  const logoHtml = logoBase64 ? `<img src="${logoBase64}" alt="Mintellect Logo" class="logo">` : '<div class="logo-text">MINTELLECT</div>';
  
  const getSimilarityLevel = (percentage) => {
    if (percentage >= 80) return 'Very High';
    if (percentage >= 60) return 'High';
    if (percentage >= 40) return 'Medium';
    if (percentage >= 20) return 'Low';
    return 'Very Low';
  };
  
  return `
    <!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Plagiarism Report</title>
      <style>
        body {
          font-family: Arial, sans-serif;
          font-size: 14px;
          line-height: 1.6;
          color: #333;
          background: white;
          padding: 20px;
          margin: 0;
        }
        
        .header {
          text-align: center;
          margin-bottom: 30px;
          border-bottom: 2px solid #4a90e2;
          padding-bottom: 20px;
        }
        
        .logo {
          max-width: 200px;
          height: auto;
          margin-bottom: 10px;
        }
        
        .logo-text {
          font-size: 24px;
          font-weight: bold;
          color: #4a90e2;
          margin-bottom: 10px;
        }
        
        h1 {
          color: #2c5aa0;
          margin: 0;
          font-size: 24px;
        }
        
        .subtitle {
          color: #666;
          margin: 5px 0 0 0;
          font-size: 16px;
        }
        
        .document-info {
          background: #f8f9fa;
          padding: 15px;
          border-radius: 5px;
          margin-bottom: 20px;
        }
        
        .info-row {
          display: flex;
          justify-content: space-between;
          margin-bottom: 8px;
        }
        
        .info-label {
          font-weight: bold;
          color: #2c5aa0;
        }
        
        .summary {
          background: #e8f4fd;
          padding: 15px;
          border-radius: 5px;
          margin-bottom: 20px;
        }
        
        .summary h2 {
          color: #2c5aa0;
          margin-top: 0;
          font-size: 18px;
        }
        
        .summary-item {
          margin-bottom: 10px;
        }
        
        .summary-label {
          font-weight: bold;
          color: #2c5aa0;
        }
        
        .similarity-section {
          margin-bottom: 25px;
        }
        
        .similarity-section h2 {
          color: #2c5aa0;
          border-bottom: 1px solid #ddd;
          padding-bottom: 5px;
          font-size: 18px;
        }
        
        .similarity-item {
          background: #f8f9fa;
          padding: 15px;
          border-radius: 5px;
          margin-bottom: 15px;
          border-left: 4px solid #4a90e2;
        }
        
        .similarity-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 10px;
        }
        
        .similarity-title {
          font-weight: bold;
          color: #2c5aa0;
          font-size: 16px;
        }
        
        .similarity-percentage {
          background: #4a90e2;
          color: white;
          padding: 4px 8px;
          border-radius: 3px;
          font-weight: bold;
          font-size: 14px;
        }
        
        .similarity-url {
          color: #666;
          font-size: 12px;
          margin-bottom: 8px;
          word-break: break-all;
        }
        
        .similarity-text {
          background: white;
          padding: 10px;
          border-radius: 3px;
          border: 1px solid #ddd;
          font-family: monospace;
          font-size: 12px;
          line-height: 1.4;
          max-height: 200px;
          overflow-y: auto;
        }
        
        .footer {
          text-align: center;
          margin-top: 40px;
          padding-top: 20px;
          border-top: 1px solid #ddd;
          color: #666;
          font-size: 12px;
        }
      </style>
    </head>
    <body>
      <div class="header">
        ${logoHtml}
        <h1>Plagiarism Detection Report</h1>
        <p class="subtitle">Generated by Mintellect AI</p>
      </div>
      
      <div class="document-info">
        <div class="info-row">
          <span class="info-label">Document Name:</span>
          <span>${documentName}</span>
        </div>
        <div class="info-row">
          <span class="info-label">Analysis Date:</span>
          <span>${new Date().toLocaleDateString()}</span>
        </div>
        <div class="info-row">
          <span class="info-label">Total Sources Checked:</span>
          <span>${sources.length}</span>
        </div>
      </div>
      
      <div class="summary">
        <h2>Summary</h2>
        <div class="summary-item">
          <span class="summary-label">Overall Similarity:</span>
          ${plagiarismData.overallSimilarity || 0}%
        </div>
        <div class="summary-item">
          <span class="summary-label">Similar Sources Found:</span>
          ${plagiarismData.similarities ? plagiarismData.similarities.length : 0}
        </div>
        <div class="summary-item">
          <span class="summary-label">Risk Level:</span>
          ${getSimilarityLevel(plagiarismData.overallSimilarity || 0)}
        </div>
      </div>
      
      ${plagiarismData.similarities && plagiarismData.similarities.length > 0 ? `
        <div class="similarity-section">
          <h2>Similar Content Found</h2>
          ${plagiarismData.similarities.map(similarity => `
            <div class="similarity-item">
              <div class="similarity-header">
                <span class="similarity-title">Source ${similarity.sourceIndex || 'Unknown'}</span>
                <span class="similarity-percentage">${similarity.percentage || 0}%</span>
              </div>
              <div class="similarity-url">${similarity.url || 'No URL available'}</div>
              <div class="similarity-text">${similarity.text || 'No text available'}</div>
            </div>
          `).join('')}
        </div>
      ` : '<p>No similar content found.</p>'}
      
      <div class="footer">
        <p>This report was generated by Mintellect AI Plagiarism Detection System.</p>
        <p>For more information, visit <a href="https://mintellect.xyz">mintellect.xyz</a></p>
      </div>
    </body>
    </html>
  `;
}

// Generate HTML for trust score report
function generateTrustScoreReportHTML(trustScoreData, documentName) {
  const logoBase64 = getLogoBase64();
  const logoHtml = logoBase64 ? `<img src="${logoBase64}" alt="Mintellect Logo" class="logo">` : '<div class="logo-text">MINTELLECT</div>';
  
  const getTrustLevel = (score) => {
    if (score >= 80) return 'Excellent';
    if (score >= 60) return 'Good';
    if (score >= 40) return 'Fair';
    if (score >= 20) return 'Poor';
    return 'Very Poor';
  };
  
  const getTrustLevelColor = (level) => {
    switch (level) {
      case 'Excellent': return '#10b981';
      case 'Good': return '#3b82f6';
      case 'Fair': return '#f59e0b';
      case 'Poor': return '#ef4444';
      default: return '#6b7280';
    }
  };
  
  return `
    <!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Trust Score Report</title>
      <style>
        body {
          font-family: Arial, sans-serif;
          font-size: 14px;
          line-height: 1.6;
          color: #333;
          background: white;
          padding: 20px;
          margin: 0;
        }
        
        .header {
          text-align: center;
          margin-bottom: 30px;
          border-bottom: 2px solid #4a90e2;
          padding-bottom: 20px;
        }
        
        .logo {
          max-width: 200px;
          height: auto;
          margin-bottom: 10px;
        }
        
        .logo-text {
          font-size: 24px;
          font-weight: bold;
          color: #4a90e2;
          margin-bottom: 10px;
        }
        
        h1 {
          color: #2c5aa0;
          margin: 0;
          font-size: 24px;
        }
        
        .subtitle {
          color: #666;
          margin: 5px 0 0 0;
          font-size: 16px;
        }
        
        .document-info {
          background: #f8f9fa;
          padding: 15px;
          border-radius: 5px;
          margin-bottom: 20px;
        }
        
        .info-row {
          display: flex;
          justify-content: space-between;
          margin-bottom: 8px;
        }
        
        .info-label {
          font-weight: bold;
          color: #2c5aa0;
        }
        
        .trust-score {
          background: #e8f4fd;
          padding: 20px;
          border-radius: 5px;
          margin-bottom: 20px;
          text-align: center;
        }
        
        .trust-score h2 {
          color: #2c5aa0;
          margin-top: 0;
          font-size: 18px;
        }
        
        .score-display {
          font-size: 48px;
          font-weight: bold;
          margin: 10px 0;
        }
        
        .trust-level {
          font-size: 24px;
          font-weight: bold;
          margin: 10px 0;
        }
        
        .factors {
          margin-bottom: 25px;
        }
        
        .factors h2 {
          color: #2c5aa0;
          border-bottom: 1px solid #ddd;
          padding-bottom: 5px;
          font-size: 18px;
        }
        
        .factor-item {
          background: #f8f9fa;
          padding: 15px;
          border-radius: 5px;
          margin-bottom: 15px;
          border-left: 4px solid #4a90e2;
        }
        
        .factor-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 10px;
        }
        
        .factor-name {
          font-weight: bold;
          color: #2c5aa0;
          font-size: 16px;
        }
        
        .factor-score {
          background: #4a90e2;
          color: white;
          padding: 4px 8px;
          border-radius: 3px;
          font-weight: bold;
          font-size: 14px;
        }
        
        .factor-description {
          color: #666;
          font-size: 14px;
        }
        
        .footer {
          text-align: center;
          margin-top: 40px;
          padding-top: 20px;
          border-top: 1px solid #ddd;
          color: #666;
          font-size: 12px;
        }
      </style>
    </head>
    <body>
      <div class="header">
        ${logoHtml}
        <h1>Trust Score Report</h1>
        <p class="subtitle">Generated by Mintellect AI</p>
      </div>
      
      <div class="document-info">
        <div class="info-row">
          <span class="info-label">Document Name:</span>
          <span>${documentName}</span>
        </div>
        <div class="info-row">
          <span class="info-label">Analysis Date:</span>
          <span>${new Date().toLocaleDateString()}</span>
        </div>
      </div>
      
      <div class="trust-score">
        <h2>Overall Trust Score</h2>
        <div class="score-display" style="color: ${getTrustLevelColor(getTrustLevel(trustScoreData.overallScore || 0))}">
          ${trustScoreData.overallScore || 0}
        </div>
        <div class="trust-level" style="color: ${getTrustLevelColor(getTrustLevel(trustScoreData.overallScore || 0))}">
          ${getTrustLevel(trustScoreData.overallScore || 0)}
        </div>
      </div>
      
      ${trustScoreData.factors && trustScoreData.factors.length > 0 ? `
        <div class="factors">
          <h2>Trust Factors</h2>
          ${trustScoreData.factors.map(factor => `
            <div class="factor-item">
              <div class="factor-header">
                <span class="factor-name">${factor.name || 'Unknown Factor'}</span>
                <span class="factor-score">${factor.score || 0}</span>
              </div>
              <div class="factor-description">${factor.description || 'No description available'}</div>
            </div>
          `).join('')}
        </div>
      ` : '<p>No trust factors available.</p>'}
      
      <div class="footer">
        <p>This report was generated by Mintellect AI Trust Score System.</p>
        <p>For more information, visit <a href="https://mintellect.xyz">mintellect.xyz</a></p>
      </div>
    </body>
    </html>
  `;
}

export default router;
